from rdkit import Chem
from rdkit.Chem import Draw
from .custom_residues import is_pi_bonded, dist
from .data import *
import networkx as nx
from .dijkstras import Branch, ShortestPath
from .smiles import getSimpleSmiles

class emap():
    def __init__(self, filename, structure, eta_moieties, chain_list):
        self.filename = filename
        self.structure = structure
        self.smiles_dict = {}
        self.residue_dict = {}
        self.ngl_dict = {}
        self.chains = chain_list
        self.eta_moieties = []
        self.user_residues = []
        self.residue_names = []
        for residue in eta_moieties:
            self._add_eta_moiety(residue)

    def store_initial_agraph(self, agraph):
        '''Stores agraph representation of emap model

        Parameters
        ----------
        agraph: Pygraphviz agraph object
            Graph theory representation of emap model

        Notes
        -----
        Attributes of nodes/edges store info on surface exposure, edge weights etc. 
        '''
        self.init_agraph = agraph

    def store_paths(self, shortest_paths):
        '''Stores pathways found by emap.

        Parameters
        ---------
        shortest_paths: array-like
            list of pyemap.ShortestPath objects representing pathways found by emap 
        '''
        self.shortest_paths = shortest_paths

    def store_paths_agraph(self, agraph):
        '''Stores agraph representation of emap model with selected pathway(s) highlighted

        Parameters
        ----------
        agraph: Pygraphviz agraph object
            Graph theory representation of emap model

        Notes
        -----
        Attributes of nodes/edges store info on surface exposure, edge weights etc. 
        '''
        self.paths_agraph = agraph

    def save_residue(self, resname, dest="",size=(200,200)):
        '''Saves image of residue to file
        '''
        mol = Chem.MolFromSmarts(self.smiles_dict.get(resname))
        if dest:
            Draw.MolToFile(mol, dest, kekulize=False, size=size)
        else:
            Draw.MolToFile(mol, resname + ".png", kekulize=False, size=size)

    def save_init_agraph(self,dest="",agraph=[]):
        '''Saves image of agraph generated by process to file
        '''
        if self.init_agraph:
            if dest:
                fn=dest
            else:
                fn = self.filename[:-4] + "_graph.png"
            self.init_agraph.draw(fn, prog='neato')
        elif agraph:
            if dest:
                fn=dest
            else:
                fn = self.filename[:-4]+"_graph.png"
            agraph.draw(fn,prog='neato')
        else:
            raise Exception("Nothing to draw.")

    def save_paths_agraph(self,dest=""):
        '''Saves image of agraph generated by pathways to file
        '''
        if self.paths_agraph:
            if dest:
                fn=dest
            else:
                fn = self.filename[:-4] + "_paths.png"
            self.paths_agraph.draw(fn, prog='neato')
        else:
            raise Exception("Nothing to draw.")
    
    def _add_residue(self, residue, node_label, smiles_str, ngl_str):
        '''
        '''
        self.smiles_dict[node_label] = smiles_str
        self.residue_dict[node_label] = residue
        self.residue_names.append(node_label)
        self.ngl_dict[node_label] = self.get_ngl_string(residue)
    
    def add_user_residue(self,residue):
        node_label = residue.resname
        smiles_str = "NYI"
        ngl_string = self.get_ngl_string(residue)
        self.user_residues.append(residue.resname)
        self._add_residue(residue,node_label,smiles_str,ngl_string)

    def add_standard_residue(self,residue,node_label):
        smiles_str = "NYI"
        ngl_string = self.get_ngl_string(residue)
        self._add_residue(residue,node_label,smiles_str,ngl_string)

    def _add_eta_moiety(self,residue):
        node_label = residue.resname
        atoms = list(residue.get_atoms())
        arom_atoms = ['O', 'P', 'N', 'C', 'S']
        res_graph = nx.Graph()
        for i in range(len(atoms)):
            for k in range(i, len(atoms)):
                if (not i == k) and is_pi_bonded(atoms[i], atoms[k]):
                    if atoms[i].element in arom_atoms and atoms[k].element in arom_atoms:
                        res_graph.add_edge(i, k)
        smiles_str = getSimpleSmiles(res_graph, atoms)
        molecule = Chem.MolFromSmarts(smiles_str)
        smiles_str = Chem.MolToSmarts(molecule, True)
        ngl_string = self.get_ngl_string(residue)
        self.eta_moieties.append(residue.resname)
        self._add_residue(residue,node_label,smiles_str,ngl_string)

    def reset_process(self):
        '''Returns emap object to state it was in after parsing.
        '''
        for res in self.residue_names:
            if res not in self.eta_moieties:
                self.ngl_dict.pop(res.resname)
                self.smiles_dict.pop(res.resname)
                self.residue_dict.pop(res.resname)
        self.residue_names = self.eta_moieties.copy()
        self.user_residues=[]
        self.shortest_paths=[]
        self.init_agraph=[]
        self.paths_agraph=[]
    
    def get_residue(self,resname):
        if resname in self.residue_dict:
            return self.residue_dict[resname]
        else:
            raise Exception("No record of any residue by that name.")

    def get_ngl_string(self,residue):
        """Determines NGL selection string for residue

        Parameters
        ----------
        residue: BioPython Residue object
        
        Returns
        -------
        select_string: str
            NGL selection string for this residue
        """
        try:
            select_string = ""
            atm_list = list(residue.get_atoms())
            first_atm = atm_list[0]
            select_string += "(" + str(first_atm.original_id[3][1]) + " and :" + str(
                first_atm.original_id[2]) + " and ." + first_atm.name + ")"
            for i in range(1, len(atm_list)):
                atm = atm_list[i]
                select_string += " or "
                select_string += "(" + str(atm.original_id[3][1]) + " and :" + str(
                    atm.original_id[2]) + " and ." + atm.name + ")"
            return select_string
        except Exception as e:
                raise Exception(e)
    
